#!/usr/bin/env ruby

require 'bundler/setup'
require 'distribot'
require 'byebug'
require 'pp'
require 'active_support/core_ext/object'
require 'active_support/core_ext/array'
require 'active_support/json'


Distribot.configure do |config|
  config.redis_url = 'redis://172.17.0.2:6379/0'
  config.rabbitmq_url = 'amqp://distribot:distribot@172.17.0.2:5672'
end

module Example
  def self.make_workflow(name)
    name += "#1"
    @workflow = Distribot::Workflow.new(
      name: name,
      phases: [
        {
          name: 'start',
          is_initial: true,
          transitions_to: 'part1'
        },
        {
          name: 'part1',
          handlers: %w(
            HardWorker
            GoodWorker
            FastWorker
            CheapWorker
            ForeignWorker
            SlowWorker
          ),
          transitions_to: 'finish'
        },
        {
          name: 'finish',
          is_final: true
        }
      ]
    )
@workflow.save!
#     @workflow.save! do |workflow|
#       Distribot.redis.decr('distribot.running.workflows')
#       new_index = Distribot.redis.incr('finished')
# puts "/////////////////////////////// ------------------------ ///////////////////"
#       max = Distribot.redis.get('distribot.max.workflows').to_i
#       current = Distribot.redis.get('distribot.running.workflows').to_i
#       diff = max - current
#       max_accelleration = 9999
#       increase = diff > max_accelleration ? max_accelleration : diff
#       increase.times do |num|
#         puts "+++++++++ SPAWN #{num + 1}/#{increase} +++++++++++"
#         Example.make_workflow("Workflow: #{new_index} -> ")
#       end
#     end
    @workflow
  end
end

pids = [ ]
pids << fork do
  phase_started = Distribot::PhaseStartedHandler.new
  sleep
end
pids << fork do
  phase_finished = Distribot::PhaseFinishedHandler.new
  sleep
end
pids << fork do
  task_finished = Distribot::TaskFinishedHandler.new
  sleep
end
pids << fork do
  handler_finished = Distribot::HandlerFinishedHandler.new
  sleep
end
pids << fork do
  workflow_finished = Distribot::WorkflowFinishedHandler.new
  sleep
end

pids << fork do
  Distribot::WorkflowCreatedHandler.new
  sleep
end

Distribot.redis.set("finished", 0)

max = ARGV.shift.to_i
max = 1 if max <= 0
puts "<ENTER> when ready:"
gets

Distribot.redis.set('distribot.workflows.running', 0)
Distribot.redis.set('distribot.workflows.max', max)
Example.make_workflow "Workflow[1]"

while true
  sleep 5
  max = Distribot.redis.get('distribot.workflows.max').to_i
  current = Distribot.redis.get('distribot.workflows.running').to_i
  puts "\tRUNNING: at #{Time.now} -- #{current} / #{max}"
  diff = max - current
  diff.times do |num|
    new_index = Distribot.redis.incr('finished')
    puts "+++++++++ SPAWN #{num + 1}/#{diff} +++++++++++"
    Example.make_workflow("Workflow: #{new_index} -> ")
  end
end

Process.waitall

