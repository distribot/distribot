#!/usr/bin/env ruby

require 'bundler/setup'
require 'distribot'
require 'byebug'
require 'pp'
require 'active_support/core_ext/object'
require 'active_support/core_ext/array'
require 'active_support/json'


class GoogleSearcher
  def self.perform(job, &callback)
    puts "#{self}: Doing job '#{job}'..."
`curl -k --silent http://www.example.com/?#{self} > /dev/null`
    callback.call()
  end

  def self.enumerate_jobs(workflow, &callback)
    # get whatever we need from workflow.meta
    jobs = (0..10).to_a
    jobs.in_groups_of(50, false).each do |chunk|
      callback.call(chunk.map{|num| {a_number: num} })
    end
  end
end


class BingSearcher < GoogleSearcher; end

class YahooSearcher < GoogleSearcher; end

class Frobnicator
  def self.perform(job, &callback)
    puts "#{self}: performing job ##{job}.."
`curl -k --silent http://www.example.com/ > /dev/null`
    callback.call()
  end
  def self.enumerate_jobs(workflow, &callback)
    callback.call((0..10).to_a.map{|id| {id: id} })
  end
end

module Distribot

  class PhaseStartedHandler
    def initialize
      Distribot.queue('distribot.workflow.phase.started').subscribe do |_, _, payload|
pp 'payload(distribot.workflow.phase.started)' => payload
        info = JSON.parse(payload, symbolize_names: true)
        workflow = Distribot::Workflow.find( info[:workflow_id] )
        phase = workflow.phase( workflow.current_phase )

        if phase.handlers.empty?
          Distribot.publish! 'distribot.workflow.phase.finished', {
            workflow_id: workflow.id,
            phase: phase.name
          }.to_json
        else
          queue_counts = phase.handlers.map do |handler|

            queue_name = "distribot.workflow.#{workflow.id}.#{phase.name}.#{handler}.tasks"

            # Announce that we need some workers to listen to the task queue:
            Distribot.publish! 'distribot.workflow.handler.start', {
              handler: handler,
              queue_name: queue_name
            }.to_json

            # Insert these jobs into the handler's queue:
            job_count = 0
            Kernel.const_get(handler).enumerate_jobs(workflow) do |jobs|
              job_count += jobs.count
              Distribot.redis.incrby queue_name, jobs.count
puts "INCREMENTED '#{queue_name}' by #{jobs.count}"
              jobs.each{|job| Distribot.publish! queue_name, job.to_json }
            end
            { queue_name: queue_name, job_count: job_count, handler: handler }
          end

          queue_counts.each do |info|
            Distribot.publish! 'distribot.workflow.phase.enqueued', info.merge(workflow_id: workflow.id).to_json
          end
        end
      end
    end
  end

  class HandlerFinishedHandler
    # XXX: need to handle end of handlers
    # because they are triggering end of phase intead (which is bad, because it's getting called once per handler)
    def initialize
      Distribot.queue('distribot.workflow.handler.finished').subscribe do |_, _, payload|
pp 'read(distribot.workflow.handler.finished)' => payload
        info = JSON.parse(payload, symbolize_names: true)
        # Figure out all this workflow's task queue counters:
        workflow = Distribot::Workflow.find(info[:workflow_id])
        counters = workflow.phase(info[:phase]).handlers.map do |handler|
          "distribot.workflow.#{workflow.id}.#{info[:phase]}.#{handler}.tasks"
        end
        HandlerRunner.cancel_consumers_for("distribot.workflow.#{workflow.id}.#{info[:phase]}.#{info[:handler]}.tasks")
        # If their counters are all at zero, then this phase is complete:
        if counters.select{|counter_key| Distribot.redis.get(counter_key).to_i > 0 }.empty?
          Distribot.publish! 'distribot.workflow.phase.finished', {
            workflow_id: workflow.id,
            phase: info[:phase]
          }.to_json
        end
      end
    end
  end

  class TaskFinishedHandler
    attr_accessor :consumer

    def initialize(workflow_id, queue_name, handler)
      semaphore = Mutex.new

      workflow = Distribot::Workflow.find(workflow_id)
      counter_key = queue_name.gsub('.finished', '')
      self.consumer = Distribot.queue(queue_name).subscribe do |_, _, payload|
        Distribot.redis.decr counter_key
        if Distribot.redis.get(counter_key).to_i <= 0
          Distribot.publish! 'distribot.workflow.handler.finished', {
            workflow_id: workflow_id,
            phase: Distribot::Workflow.find(workflow_id).current_phase,
            handler: handler
          }.to_json
          self.cancel

        end
      end
    end

    def cancel
      self.consumer.cancel
    end
  end

  class PhaseEnqueuedHandler
    def initialize
      Distribot.queue('distribot.workflow.phase.enqueued').subscribe do |_, _, payload|
        info = JSON.parse(payload, symbolize_names: true)
pp 'read(distribot.workflow.phase.enqueued)' => payload
        TaskFinishedHandler.new( info[:workflow_id], info[:queue_name] + '.finished', info[:handler] )
#puts "WAITING FOR ALL WORKERS TO FINISH..."

      end
    end
  end

  class HandlerRunner
    @@consumers = [ ]

    def initialize
      semaphore = Mutex.new
      Distribot.queue('distribot.workflow.handler.start').subscribe do |_, _, payload|
pp 'payload(distribot.workflow.handler.start)' => payload
        info = JSON.parse(payload, symbolize_names: true)
        finished_queue = info[:queue_name] + '.finished'
        @@consumers << Distribot.queue(info[:queue_name]).subscribe do |_, _, payload|
          task = JSON.parse(payload, symbolize_names: true)
Thread.new do
          Kernel.const_get(info[:handler]).perform task do
            # Announce this task as finished:
            Distribot.publish! finished_queue, {foo: :bar}.to_json
          end
end
        end
      end
    end

    def self.add_consumer(consumer)
      @@consumers << consumer
    end

    def self.cancel_consumers_for(queue_name)
      @@consumers.select{|consumer| consumer.queue.name == queue_name}.map{|consumer| puts "Cancelling consumer of #{consumer.queue.name}"; consumer}.map(&:cancel)
      @@consumers = @@consumers.delete_if{|x| x.queue.name == queue_name}
    end
  end

  class PhaseFinishedHandler
    def initialize
      Distribot.queue('distribot.workflow.phase.finished').subscribe do |_, _, payload|
        info = JSON.parse(payload, symbolize_names: true)
        workflow = Distribot::Workflow.find(info[:workflow_id])
        if workflow.current_phase == info[:phase]
          if workflow.next_phase
pp 'payload(distribot.workflow.phase.finished)' => payload
pp workflow.id => 'transition_to(' + workflow.next_phase + ')'
            workflow.transition_to! workflow.next_phase
          else
            # This workflow is finished - send it on down the line!
            Distribot.publish! 'distribot.workflow.finished', {
              workflow_id: workflow.id
            }.to_json
          end
        end
      end
    end
  end

  class WorkflowFinishedHandler
    def initialize
      Distribot.queue('distribot.workflow.finished').subscribe do |_, _, payload|
pp 'payload(distribot.workflow.finished)' => payload
puts "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
        info = JSON.parse(payload, symbolize_names: true)
        workflow = Distribot::Workflow.find(info[:workflow_id])
puts "WORKFLOW #{workflow.name} FINISHED!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        # TODO: mark this workflow as 'finished'
        # Maybe via Sidekiq.
      end
    end
  end
end


def make_workflow(name)
  @workflow = Distribot::Workflow.new(
    name: name,
    phases: [
      {
        name: 'pending',
        is_initial: true,
        transitions_to: 'phase1'
      },
      {
        name: 'phase1',
        handlers: [ 'GoogleSearcher', 'BingSearcher', 'YahooSearcher' ],
        transitions_to: 'phase2'
      },
      {
        name: 'phase2',
        handlers: [ 'Frobnicator' ],
        transitions_to: 'phase3'
      },
      {
        name: 'phase3',
        handlers: [ 'GoogleSearcher', 'BingSearcher', 'YahooSearcher' ],
        transitions_to: 'phase4'
      },
      {
        name: 'phase4',
        handlers: [ 'GoogleSearcher', 'BingSearcher', 'YahooSearcher' ],
        transitions_to: 'phase5'
      },
      {
        name: 'phase5',
        handlers: [ 'GoogleSearcher', 'BingSearcher', 'YahooSearcher' ],
        transitions_to: 'finished'
      },
      {
        name: 'finished',
        is_final: true
      }
    ]
  )
  @workflow.save!
end

started = Distribot::PhaseStartedHandler.new
handler_runner = Distribot::HandlerRunner.new
enqueued = Distribot::PhaseEnqueuedHandler.new
handler_finished = Distribot::HandlerFinishedHandler.new
phase_finished = Distribot::PhaseFinishedHandler.new
finished = Distribot::WorkflowFinishedHandler.new

Thread.new do
  (1..50).to_a.each do |num|
    puts "MAKING WORKFLOW \##{num}"
    make_workflow "workflow number #{num}"
    sleep 2
  end
  puts "Finished making consumers (from now on, only Cancelling)"
end

sleep 1
Distribot::WorkflowCreatedHandler.new



sleep

