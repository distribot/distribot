#!/usr/bin/env ruby

require 'bundler/setup'
require 'distribot'
require 'byebug'
require 'pp'
require 'active_support/core_ext/object'
require 'active_support/core_ext/array'
require 'active_support/json'


class GoogleSearcher
  def self.perform(job, &callback)
    puts "#{self}: Doing job '#{job}'..."
    callback.call()
  end

  def self.enumerate_jobs(workflow, &callback)
    # get whatever we need from workflow.meta
    jobs = (0..10).to_a
    jobs.in_groups_of(50, false).each do |chunk|
      callback.call(chunk.map{|num| {a_number: num} })
    end
  end
end


class BingSearcher
  def self.perform(job, &callback)
    puts "#{self}: Doing job '#{job}'..."
    callback.call()
  end

  def self.enumerate_jobs(workflow, &callback)
    # get whatever we need from workflow.meta
    jobs = (0..10).to_a
    jobs.in_groups_of(50, false).each do |chunk|
      callback.call(chunk.map{|num| {a_number: num} })
    end
  end
end

class YahooSearcher < GoogleSearcher; end

class Frobnicator
  def self.perform(job, &callback)
    puts "#{self}: performing job ##{job}.."
    callback.call()
  end
  def self.enumerate_jobs(workflow, &callback)
    (0..10).to_a.each do |id|
      callback.call([{id: id}])
    end
  end
end

module Distribot

  class WorkflowCreatedHandler
    def initialize
      Distribot.queue('distribot.workflow.created').subscribe(block: true) do |_, _, payload|
pp 'payload(distribot.workflow.created)' => payload
        info = JSON.parse(payload, symbolize_names: true)
        workflow = Distribot::Workflow.find( info[:workflow_id] )
        workflow.transition_to! workflow.next_phase
      end
    end
  end

  class PhaseStartedHandler
    def initialize
      Distribot.queue('distribot.workflow.phase.started').subscribe do |_, _, payload|
pp 'payload(distribot.workflow.phase.started)' => payload
        info = JSON.parse(payload, symbolize_names: true)
        workflow = Distribot::Workflow.find( info[:workflow_id] )
        phase = workflow.phase( workflow.current_phase )
        queue_counts = phase.handlers.map do |handler|

          queue_name = "distribot.workflow.#{workflow.id}.#{phase.name}.#{handler}.tasks"

          # Announce that we need some workers to listen to the task queue:
          Distribot.publish! 'distribot.workflow.handler.start', {
            handler: handler,
            queue_name: queue_name
          }.to_json

          # Insert these jobs into the handler's queue:
          job_count = 0
          Kernel.const_get(handler).enumerate_jobs(workflow) do |jobs|
            job_count += jobs.count
            Distribot.redis.incrby queue_name, jobs.count
            jobs.each{|job| Distribot.publish! queue_name, job.to_json }
          end
          { queue_name: queue_name, job_count: job_count, handler: handler }
        end

        queue_counts.each do |info|
          Distribot.publish! 'distribot.workflow.phase.enqueued', info.merge(workflow_id: workflow.id).to_json
        end
      end
    end
  end

  class HandlerFinishedHandler
    # XXX: need to handle end of handlers
    # because they are triggering end of phase intead (which is bad, because it's getting called once per handler)
    def initialize
      Distribot.queue('distribot.workflow.handler.finished').subscribe do |_, _, payload|
pp 'read(distribot.workflow.handler.finished)' => payload
        info = JSON.parse(payload, symbolize_names: true)
        # Figure out all this workflow's task queue counters:
        workflow = Distribot::Workflow.find(info[:workflow_id])
        counters = workflow.phase(info[:phase]).handlers.map do |handler|
          "distribot.workflow.#{workflow.id}.#{info[:phase]}.#{handler}.tasks"
        end
        # If their counters are all at zero, then this phase is complete:
        if counters.select{|counter_key| Distribot.redis.get(counter_key).to_i > 0 }.empty?
          Distribot.publish! 'distribot.workflow.phase.finished', {
            workflow_id: workflow.id,
            phase: info[:phase]
          }.to_json
        end
      end
    end
  end

  class TaskFinishedHandler
    def initialize(workflow_id, queue_name, handler)
      workflow = Distribot::Workflow.find(workflow_id)
      counter_key = queue_name.gsub('.finished', '')
      begin
        Distribot.queue(queue_name).subscribe(block: true) do |_, _, payload|
          Distribot.redis.decr counter_key
          if Distribot.redis.get(counter_key).to_i <= 0
            Distribot.publish! 'distribot.workflow.handler.finished', {
              workflow_id: workflow_id,
              phase: Distribot::Workflow.find(workflow_id).current_phase,
              handler: handler
            }.to_json
          end
        end
      rescue StandardError => e
        puts "//////////////////////// FINISH ///////////////////"
      end
    end
  end

  class PhaseEnqueuedHandler
    def initialize
      Distribot.queue('distribot.workflow.phase.enqueued').subscribe do |_, _, payload|
        info = JSON.parse(payload, symbolize_names: true)
pp 'read(distribot.workflow.phase.enqueued)' => payload
        TaskFinishedHandler.new( info[:workflow_id], info[:queue_name] + '.finished', info[:handler] )
puts "WAITING FOR ALL WORKERS TO FINISH..."

      end
    end
  end

  class HandlerRunner
    def initialize
      Distribot.queue('distribot.workflow.handler.start').subscribe do |_, _, payload|
pp 'payload(distribot.workflow.handler.start)' => payload
        info = JSON.parse(payload, symbolize_names: true)
        finished_queue = info[:queue_name] + '.finished'
        Distribot.queue(info[:queue_name]).subscribe do |_, _, payload|
          task = JSON.parse(payload, symbolize_names: true)
          Kernel.const_get(info[:handler]).perform task do
            # Announce this task as finished:
            Distribot.publish! finished_queue, {foo: :bar}.to_json
          end
        end
      end
    end
  end

  class PhaseFinishedHandler
    def initialize
      Distribot.queue('distribot.workflow.phase.finished').subscribe do |_, _, payload|
        info = JSON.parse(payload, symbolize_names: true)
        workflow = Distribot::Workflow.find(info[:workflow_id])
        if workflow.current_phase == info[:phase]
          if workflow.next_phase
pp 'payload(distribot.workflow.phase.finished)' => payload
pp workflow.id => 'transition_to(' + workflow.next_phase + ')'
            workflow.transition_to! workflow.next_phase
          else
            # This workflow is finished - send it on down the line!
            Distribot.publish! 'distribot.workflow.finished', {
              workflow_id: workflow.id
            }.to_json
          end
        end
      end
    end
  end

  class WorkflowFinishedHandler
    def initialize
      Distribot.queue('distribot.workflow.finished').subscribe do |_, _, payload|
pp 'payload(distribot.workflow.finished)' => payload
        info = JSON.parse(payload, symbolize_names: true)
        workflow = Distribot::Workflow.find(info[:workflow_id])
        # TODO: mark this workflow as 'finished'
        # Maybe via Sidekiq.
      end
    end
  end
end


@workflow = Distribot::Workflow.new(
  name: 'test',
  phases: [
    {
      name: 'pending',
      is_initial: true,
      transitions_to: 'working'
    },
    {
      name: 'working',
      handlers: [ 'GoogleSearcher', 'BingSearcher', 'YahooSearcher' ],
      transitions_to: 'frobnicating'
    },
    {
      name: 'frobnicating',
      handlers: [ 'Frobnicator' ],
      transitions_to: 'finished'
    },
    {
      name: 'finished',
      is_final: true
    }
  ]
)
@workflow.save!

started = Distribot::PhaseStartedHandler.new
handler_runner = Distribot::HandlerRunner.new
enqueued = Distribot::PhaseEnqueuedHandler.new
handler_finished = Distribot::HandlerFinishedHandler.new
phase_finished = Distribot::PhaseFinishedHandler.new
finished = Distribot::WorkflowFinishedHandler.new

Distribot::WorkflowCreatedHandler.new














__END__

conn = Distribot.bunny
conn.start
ch = conn.create_channel
x = ch.default_exchange

workflow_created_queue = ch.queue('distribot.workflow.created', auto_delete: true, durable: true)
workflow_created_queue.subscribe do |_, _, payload|
  puts "!! Workflow created: #{payload}"

  # Transition to its first phase:
  info = JSON.parse(payload, symbolize_names: true)
  workflow = Distribot::Workflow.find( info[:id] )
  workflow.transition_to! workflow.phases.reject{|x| x[:is_initial] }.first[:name]

end

workflow_finished_queue = ch.queue('distribot.workflow.finished', auto_delete: true, durable: true)
workflow_finished_queue.subscribe do |_, _, payload|
  puts ">> Workflow FINISHED: #{payload}"
end

@json = JSON.parse( File.read('spec/fixtures/simple_workflow.json'), symbolize_names: true )
@workflow = Distribot::Workflow.new(
  name: @json[:name],
  phases: @json[:phases]
)
@workflow.save!
x.publish {id: @workflow.id}.to_json, routing_key: workflow_created_queue.name

task_finished_queue = ch.queue("distribot.workflow.#{@workflow.id}.phase.searching.task.finished", auto_delete: true, durable: true)
phase_started_queue = ch.queue("distribot.#{@workflow.id}.phase.started", auto_delete: true, durable: true)
phase_finished_queue = ch.queue("distribot.#{@workflow.id}.phase.finished", auto_delete: true, durable: true)


google_searcher_handler_queue = ch.queue("distribot.workflow.#{@workflow.id}.phase.searching.handler.GoogleSearcher", auto_delete: false, durable: true)
job_queues = [
  google_searcher_handler_queue
]

workflow_created_queue.subscribe do |_, _, payload|
  info = JSON.parse(payload, symbolize_names: true)
  workflow = Distribot::Workflow.find_by_id(info[:id])
  phase_started_queue.subscribe
end

@workflow.transition_to! 'searching'
x.publish( {workflow: @workflow.id}.to_json, routing_key: searching_phase_queue.name )


@expected_task_count = 0
searching_phase_queue.subscribe do |delivery_info, metadata, payload|
  puts "Payload: '#{payload}' => search.searching"
  # Enqueue all the jobs to all the job queues:
  jobs = (1..100_000).to_a.map{|x| {job_id: x}}
  jobs.each do |job|
    job_queues.each do |job_queue|
      @expected_task_count += 1
      x.publish job.to_json, routing_key: job_queue.name
    end
  end

  # Announce that we have finished enqueueing all the jobs (and we can start waiting for them to be finished):
  puts "ALL JOBS ENQUEUED"
  x.publish 'begin-monitoring', routing_key: searching_phase_started_queue.name
end



# Be ready for when search.searching jobs finish:
searching_phase_started_queue.subscribe do |delivery_info, metadata, payload|
  puts "STARTING TO MONITOR task-finished queue:"
  @announced_phase_finish = false
  @announced_tasks_finished = 0
  task_finished_queue.subscribe do |delivery_info, metadata, payload|
    puts "TASK FINISHED: '#{payload}'"
    @announced_tasks_finished += 1
    unless @announced_phase_finish
      all_job_queues_are_empty = @announced_tasks_finished >= @expected_task_count
      if all_job_queues_are_empty
        puts "ALL JOBS ARE DONE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        @announced_phase_finish = true
      end
    end
  end

  # Listen for new tasks for the GoogleSearcher handler:
  google_searcher_handler_queue.subscribe do |delivery_info, metadata, payload|
    GoogleSearcher.perform payload do
      x.publish payload, routing_key: task_finished_queue.name
    end
  end
end

sleep 10
byebug
puts "OK"
